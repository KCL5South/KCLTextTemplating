// ------------------------------------------------------------------------------
//  <auto-generated>
//      This code was generated by SpecFlow (http://www.specflow.org/).
//      SpecFlow Version:1.9.0.77
//      SpecFlow Generator Version:1.9.0.0
//      Runtime Version:4.0.30319.17929
// 
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </auto-generated>
// ------------------------------------------------------------------------------
#region Designer generated code
#pragma warning disable
namespace Acceptance.Tests.Features
{
    using TechTalk.SpecFlow;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("TechTalk.SpecFlow", "1.9.0.77")]
    [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [NUnit.Framework.TestFixtureAttribute()]
    [NUnit.Framework.DescriptionAttribute("We should be able to reference two different assemblies with similar names")]
    public partial class WeShouldBeAbleToReferenceTwoDifferentAssembliesWithSimilarNamesFeature
    {
        
        private static TechTalk.SpecFlow.ITestRunner testRunner;
        
#line 1 "TextTransform.Assemblies.feature"
#line hidden
        
        [NUnit.Framework.TestFixtureSetUpAttribute()]
        public virtual void FeatureSetup()
        {
            testRunner = TechTalk.SpecFlow.TestRunnerManager.GetTestRunner();
            TechTalk.SpecFlow.FeatureInfo featureInfo = new TechTalk.SpecFlow.FeatureInfo(new System.Globalization.CultureInfo("en-US"), "We should be able to reference two different assemblies with similar names", @"This spawned from needing to reference both the Mono.TextTemplating.dll
and the Mono.TextTemplating.Utility.dll in my templates.

The code that is loading the assemblies was simply 
checking that an assembly name starts with another assembly name 
without the extension.

Therefore System.Data could be loaded up when System.Data.Utility is needed.", ProgrammingLanguage.CSharp, ((string[])(null)));
            testRunner.OnFeatureStart(featureInfo);
        }
        
        [NUnit.Framework.TestFixtureTearDownAttribute()]
        public virtual void FeatureTearDown()
        {
            testRunner.OnFeatureEnd();
            testRunner = null;
        }
        
        [NUnit.Framework.SetUpAttribute()]
        public virtual void TestInitialize()
        {
        }
        
        [NUnit.Framework.TearDownAttribute()]
        public virtual void ScenarioTearDown()
        {
            testRunner.OnScenarioEnd();
        }
        
        public virtual void ScenarioSetup(TechTalk.SpecFlow.ScenarioInfo scenarioInfo)
        {
            testRunner.OnScenarioStart(scenarioInfo);
        }
        
        public virtual void ScenarioCleanup()
        {
            testRunner.CollectScenarioErrors();
        }
        
        [NUnit.Framework.TestAttribute()]
        [NUnit.Framework.DescriptionAttribute("I should be able to instantiate an object from Mono.TextTemplating.Utility.dll")]
        public virtual void IShouldBeAbleToInstantiateAnObjectFromMono_TextTemplating_Utility_Dll()
        {
            TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("I should be able to instantiate an object from Mono.TextTemplating.Utility.dll", ((string[])(null)));
#line 13
this.ScenarioSetup(scenarioInfo);
#line hidden
#line 14
 testRunner.When("I have a template with content of:", @"<#@ template language=""C#"" debug=""false"" hostspecific=""true""#>
<#@ output extension="".cs""#>
<#@ assembly name=""..\Reference\Mono.TextTemplating.Utility.dll"" #>
<#@ import namespace=""Mono.TextTemplating.Utility.EntityFramework"" #>
<#= new NullHost().ToString() #>", ((TechTalk.SpecFlow.Table)(null)), "When ");
#line hidden
#line 22
 testRunner.Then("TextTemplate.exe should produce output of:", "Mono.TextTemplating.Utility.EntityFramework.NullHost", ((TechTalk.SpecFlow.Table)(null)), "Then ");
#line hidden
            this.ScenarioCleanup();
        }
        
        [NUnit.Framework.TestAttribute()]
        [NUnit.Framework.DescriptionAttribute("I should still be able to load assemblies from the GAC")]
        public virtual void IShouldStillBeAbleToLoadAssembliesFromTheGAC()
        {
            TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("I should still be able to load assemblies from the GAC", ((string[])(null)));
#line 27
this.ScenarioSetup(scenarioInfo);
#line hidden
#line 28
 testRunner.When("I have a template with content of:", "<#@ template language=\"C#\" debug=\"false\" hostspecific=\"true\"#>\r\n<#@ output extens" +
                    "ion=\".cs\"#>\r\n<#@ assembly name=\"System.Data.dll\" #>\r\n<#= System.Data.CommandType" +
                    ".StoredProcedure.ToString() #>", ((TechTalk.SpecFlow.Table)(null)), "When ");
#line hidden
#line 35
 testRunner.Then("TextTemplate.exe should produce output of:", "StoredProcedure", ((TechTalk.SpecFlow.Table)(null)), "Then ");
#line hidden
            this.ScenarioCleanup();
        }
    }
}
#pragma warning restore
#endregion
